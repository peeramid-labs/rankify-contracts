diff --git a/deploy/mao.ts b/deploy/mao.ts
index d3915f8..ad393aa 100644
--- a/deploy/mao.ts
+++ b/deploy/mao.ts
@@ -184,6 +184,21 @@ const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
     log('GovernanceToken already registered in CodeIndex');
   }
 
+  const governorDeployment = await deploy('Governor', {
+    from: deployer,
+    skipIfAlreadyDeployed: true,
+  });
+
+  const governorDeploymentCode = await hre.ethers.provider.getCode(governorDeployment.address);
+  const governorDeploymentCodeId = ethers.utils.keccak256(governorDeploymentCode);
+  const governorDeploymentCodeIdAddress = await codeIndexContract.get(governorDeploymentCodeId);
+  if (governorDeploymentCodeIdAddress === ethers.constants.AddressZero) {
+    log('Registering Governor in CodeIndex...');
+    await (await codeIndexContract.register(governorDeployment.address)).wait(1);
+  } else {
+    log('Governor already registered in CodeIndex');
+  }
+
   const pc = poseidonContract;
   const ph5 = await deploy('Poseidon5', {
     from: deployer,
diff --git a/scripts/instantiateMAO.ts b/scripts/instantiateMAO.ts
index 6524c0a..50bb1c4 100644
--- a/scripts/instantiateMAO.ts
+++ b/scripts/instantiateMAO.ts
@@ -1,6 +1,7 @@
 import { Distributor } from '../types';
 import { BytesLike } from 'ethers';
 import { Signer } from 'ethers';
+import { parseInstantiated } from './parseInstantiated';
 
 export const instantiateMAO = async ({
   distributor,
@@ -21,15 +22,7 @@ export const instantiateMAO = async ({
   if (evts.length > 1) throw new Error('Multiple Instantiated events found');
   const instances = evts[0].args.instances;
 
-  return {
-    govToken: instances[0],
-    govTokenAccessManager: instances[1],
-    ACIDInstance: instances[2],
-    ACIDAccessManager: instances[10],
-    rankToken: instances[11],
-    instanceId: evts[0].args.newInstanceId,
-    distributorsId: evts[0].args.distributionId,
-  };
+  return parseInstantiated(instances);
 };
 
 export default instantiateMAO;
diff --git a/scripts/libraries/generateDistributorData.ts b/scripts/libraries/generateDistributorData.ts
index 9048fb9..2021e69 100644
--- a/scripts/libraries/generateDistributorData.ts
+++ b/scripts/libraries/generateDistributorData.ts
@@ -4,7 +4,7 @@ import { MAODistribution } from '../../types/src/distributions/MAODistribution';
 export function generateDistributorData(args: MAODistribution.DistributorArgumentsStruct): string {
   const data = ethers.utils.defaultAbiCoder.encode(
     [
-      'tuple(tuple(string tokenName, string tokenSymbol, uint256[] preMintAmounts, address[] preMintReceivers) tokenSettings, tuple(uint256 principalCost, uint256 principalTimeConstant, string rankTokenURI, string rankTokenContractURI, address owner, address paymentToken) rankifySettings)',
+      'tuple(tuple(string tokenName, string tokenSymbol, uint256[] preMintAmounts, address[] preMintReceivers, string orgName, uint48 votingDelay, uint32 votingPeriod, uint256 quorum) govSettings, tuple(uint256 principalCost, uint256 principalTimeConstant, string rankTokenURI, string rankTokenContractURI, address paymentToken) rankifySettings)',
     ],
     [args],
   );
diff --git a/scripts/parseInstantiated.ts b/scripts/parseInstantiated.ts
index e101fe2..242a7b0 100644
--- a/scripts/parseInstantiated.ts
+++ b/scripts/parseInstantiated.ts
@@ -1,4 +1,5 @@
 export interface MAOInstances {
+  governor: string;
   govToken: string;
   govTokenAccessManager: string;
   ACIDInstance: string;
@@ -10,8 +11,9 @@ export const parseInstantiated = (instances: string[]): MAOInstances => {
   return {
     govToken: instances[0],
     govTokenAccessManager: instances[1],
-    ACIDInstance: instances[2],
-    ACIDAccessManager: instances[10],
-    rankToken: instances[11],
+    governor: instances[2],
+    ACIDInstance: instances[3],
+    ACIDAccessManager: instances[4],
+    rankToken: instances[5],
   };
 };
diff --git a/src/Governor.sol b/src/Governor.sol
new file mode 100644
index 0000000..6dc7908
--- /dev/null
+++ b/src/Governor.sol
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: MIT
+// Compatible with OpenZeppelin Contracts ^5.0.0
+pragma solidity ^0.8.27;
+
+import {GovernorUpgradeable} from "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";
+import {GovernorCountingSimpleUpgradeable} from "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol";
+import {GovernorSettingsUpgradeable} from "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol";
+import {GovernorStorageUpgradeable} from "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorStorageUpgradeable.sol";
+import {GovernorVotesUpgradeable} from "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";
+import {GovernorVotesQuorumFractionUpgradeable} from "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol";
+import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol";
+import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
+
+/// @custom:security-contact sirt@peeramid.xyz
+contract Governor is Initializable, GovernorUpgradeable, GovernorSettingsUpgradeable, GovernorCountingSimpleUpgradeable, GovernorStorageUpgradeable, GovernorVotesUpgradeable, GovernorVotesQuorumFractionUpgradeable {
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
+
+    function initialize(string memory name, IVotes _token, uint48 votingDelay, uint32 votingPeriod, uint256 quorum)
+        public initializer
+    {
+        __Governor_init(name);
+        __GovernorSettings_init(votingDelay, votingPeriod, 1e18);
+        __GovernorCountingSimple_init();
+        __GovernorStorage_init();
+        __GovernorVotes_init(_token);
+        __GovernorVotesQuorumFraction_init(quorum);
+    }
+
+    // The following functions are overrides required by Solidity.
+
+    function state(uint256 proposalId)
+        public
+        view
+        override(GovernorUpgradeable)
+        returns (ProposalState)
+    {
+        return super.state(proposalId);
+    }
+
+    function proposalNeedsQueuing(uint256 proposalId)
+        public
+        view
+        override(GovernorUpgradeable)
+        returns (bool)
+    {
+        return super.proposalNeedsQueuing(proposalId);
+    }
+
+    function proposalThreshold()
+        public
+        view
+        override(GovernorUpgradeable, GovernorSettingsUpgradeable)
+        returns (uint256)
+    {
+        return super.proposalThreshold();
+    }
+
+    function _propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description, address proposer)
+        internal
+        override(GovernorUpgradeable, GovernorStorageUpgradeable)
+        returns (uint256)
+    {
+        return super._propose(targets, values, calldatas, description, proposer);
+    }
+
+    function _queueOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
+        internal
+        override(GovernorUpgradeable)
+        returns (uint48)
+    {
+        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);
+    }
+
+    function _executeOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
+        internal
+        override(GovernorUpgradeable)
+    {
+        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);
+    }
+
+    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
+        internal
+        override(GovernorUpgradeable)
+        returns (uint256)
+    {
+        return super._cancel(targets, values, calldatas, descriptionHash);
+    }
+
+    function _executor()
+        internal
+        view
+        override(GovernorUpgradeable)
+        returns (address)
+    {
+        return super._executor();
+    }
+}
diff --git a/src/distributions/MAODistribution.sol b/src/distributions/MAODistribution.sol
index c17d1c3..28a875d 100644
--- a/src/distributions/MAODistribution.sol
+++ b/src/distributions/MAODistribution.sol
@@ -13,9 +13,21 @@ import "../initializers/RankifyInstanceInit.sol";
 import {ERC165Checker} from "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";
 import "@peeramid-labs/eds/src/abstracts/CodeIndexer.sol";
 import "hardhat/console.sol";
-import {TokenSettings} from "../vendor/aragon/interfaces.sol";
 import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
 import {ShortStrings, ShortString} from "@openzeppelin/contracts/utils/ShortStrings.sol";
+import {IGovernor} from "@openzeppelin/contracts/governance/IGovernor.sol";
+import {DistributableGovernanceERC20} from "../tokens/DistributableGovernanceERC20.sol";
+import {Governor} from "../Governor.sol";
+struct MAOApp {
+    IRankifyInstance fellowship;
+    RankToken rankToken;
+    DistributableGovernanceERC20 governanceToken;
+    IGovernor DAO;
+    SimpleAccessManager rankTokenManager;
+    SimpleAccessManager govTokenManager;
+}
+
+
 /**
  * @title MAODistribution
  * @dev This contract implements the IDistribution and CodeIndexer interfaces. It uses the Clones library for address cloning.
@@ -29,19 +41,22 @@ contract MAODistribution is IDistribution, CodeIndexer {
         uint96 principalTimeConstant;
         string rankTokenURI;
         string rankTokenContractURI;
-        address owner;
         address paymentToken;
     }
 
-    struct TokenArguments {
+    struct GovernanceArgs {
         string tokenName;
         string tokenSymbol;
         uint256[] preMintAmounts;
         address[] preMintReceivers;
+        string orgName;
+        uint48 votingDelay;
+        uint32 votingPeriod;
+        uint256 quorum;
     }
 
     struct DistributorArguments {
-        TokenArguments tokenSettings;
+        GovernanceArgs govSettings;
         UserRankifySettings rankifySettings;
     }
 
@@ -58,13 +73,13 @@ contract MAODistribution is IDistribution, CodeIndexer {
     address private immutable _poseidon5;
     address private immutable _poseidon6;
     address private immutable _poseidon2;
+    address private immutable _DAO;
 
     /**
      * @notice Initializes the contract with the provided parameters and performs necessary checks.
      * @dev Retrieves contract addresses from a contract index using the provided identifiers
      *      and initializes the distribution system.
      * @dev WARNING: distributionName must be less then 31 bytes long to comply with ShortStrings immutable format
-     * @param trustedForwarder Address of the trusted forwarder for meta-transactions (WARNING: Not yet reviewed)
      * @param rankTokenCodeId Identifier for the rank token implementation in CodeIndex
      * @param RankifyDIistributionId Identifier for the Rankify distribution implementation
      * @param accessManagerId Identifier for the access manager implementation
@@ -74,12 +89,12 @@ contract MAODistribution is IDistribution, CodeIndexer {
      * @param minParticipantsInCircle Minimum number of participants in a circle
      */
     constructor(
-        address trustedForwarder,
         address[] memory zkpVerifier,
         bytes32 rankTokenCodeId,
         bytes32 RankifyDIistributionId,
         bytes32 accessManagerId,
         bytes32 governanceERC20BaseId,
+        bytes32 DAOId,
         string memory distributionName,
         LibSemver.Version memory distributionVersion,
         uint256 minParticipantsInCircle
@@ -87,7 +102,6 @@ contract MAODistribution is IDistribution, CodeIndexer {
         require(minParticipantsInCircle > 2, "minParticipantsInCircle must be greater than 2");
         _minParticipantsInCircle = minParticipantsInCircle;
 
-        _trustedForwarder = trustedForwarder;
         _distributionName = ShortStrings.toShortString(distributionName);
         _distributionVersion = LibSemver.toUint256(distributionVersion);
         _rankTokenBase = getContractsIndex().get(rankTokenCodeId);
@@ -121,16 +135,19 @@ contract MAODistribution is IDistribution, CodeIndexer {
         if (_accessManagerBase == address(0)) {
             revert("Access manager base not found");
         }
+        _DAO = getContractsIndex().get(DAOId);
+        if (_DAO == address(0)) {
+            revert("DAO base not found");
+        }
         require(
             ERC165Checker.supportsInterface(_accessManagerBase, type(IERC7746).interfaceId),
             "Access manager does not support IERC7746"
         );
     }
 
-    function createToken(TokenArguments memory args) internal returns (address[] memory instances, bytes32, uint256) {
+    function createOrg(GovernanceArgs memory args) internal returns (address[] memory instances, bytes32, uint256) {
         MintSettings memory mintSettings = MintSettings(args.preMintReceivers, args.preMintAmounts);
         address token = _governanceERC20Base.clone();
-        TokenSettings memory tokenSettings = TokenSettings(token, args.tokenName, args.tokenSymbol);
 
         SimpleAccessManager.SimpleAccessManagerInitializer[]
             memory govTokenAccessSettings = new SimpleAccessManager.SimpleAccessManagerInitializer[](1);
@@ -140,24 +157,35 @@ contract MAODistribution is IDistribution, CodeIndexer {
 
         SimpleAccessManager govTokenAccessManager = SimpleAccessManager(_accessManagerBase.clone());
 
-        govTokenAccessManager.initialize(govTokenAccessSettings, tokenSettings.addr, IDistributor(msg.sender)); // msg.sender must be IDistributor or it will revert
-        DistributableGovernanceERC20(tokenSettings.addr).initialize(
-            tokenSettings.name,
-            tokenSettings.symbol,
+        govTokenAccessManager.initialize(govTokenAccessSettings, token, IDistributor(msg.sender)); // msg.sender must be IDistributor or it will revert
+        DistributableGovernanceERC20(token).initialize(
+            args.tokenName,
+            args.tokenSymbol,
             mintSettings,
             address(govTokenAccessManager)
         );
 
-        address[] memory returnValue = new address[](2);
+        address payable governor = payable(_DAO.clone());
+        Governor(governor).initialize(
+            args.orgName,
+            DistributableGovernanceERC20(token),
+            args.votingDelay,
+            args.votingPeriod,
+            args.quorum
+        );
+
+        address[] memory returnValue = new address[](3);
         returnValue[0] = token;
         returnValue[1] = address(govTokenAccessManager);
+        returnValue[2] = governor;
 
         return (returnValue, "OSxDistribution", 1);
     }
 
     function createRankify(
         UserRankifySettings memory args,
-        address derivedToken
+        address derivedToken,
+        address governor
     ) internal returns (address[] memory instances, bytes32, uint256) {
         address rankToken = _rankTokenBase.clone();
 
@@ -200,7 +228,7 @@ contract MAODistribution is IDistribution, CodeIndexer {
             args.rankTokenURI,
             args.rankTokenContractURI,
             address(rankTokenAccessManager),
-            args.owner
+            governor
         );
 
         (
@@ -215,7 +243,7 @@ contract MAODistribution is IDistribution, CodeIndexer {
             principalTimeConstant: args.principalTimeConstant,
             minimumParticipantsInCircle: _minParticipantsInCircle,
             paymentToken: args.paymentToken,
-            beneficiary: args.owner,
+            beneficiary: governor,
             derivedToken: derivedToken,
             proposalIntegrityVerifier: _proposalIntegrityVerifier,
             poseidon5: _poseidon5,
@@ -228,12 +256,10 @@ contract MAODistribution is IDistribution, CodeIndexer {
             LibSemver.toString(LibSemver.parse(RankifyDistributionVersion)),
             RankifyInit
         );
-        address[] memory returnValue = new address[](RankifyDistrAddresses.length + 2);
-        for (uint256 i; i < RankifyDistrAddresses.length; ++i) {
-            returnValue[i] = RankifyDistrAddresses[i];
-        }
-        returnValue[RankifyDistrAddresses.length] = address(rankTokenAccessManager);
-        returnValue[RankifyDistrAddresses.length + 1] = rankToken;
+        address[] memory returnValue = new address[](3);
+        returnValue[0] = RankifyDistrAddresses[0]; // Diamond Proxy
+        returnValue[1] = address(rankTokenAccessManager);
+        returnValue[2] = rankToken;
 
         return (returnValue, RankifyDistributionName, RankifyDistributionVersion);
     }
@@ -244,15 +270,15 @@ contract MAODistribution is IDistribution, CodeIndexer {
      * @return instances An array of addresses representing the new instances.
      * @return distributionName A bytes32 value representing the name of the distribution.
      * @return distributionVersion A uint256 value representing the version of the distribution.
-     * @dev `instances` array contents: GovernanceToken, Gov Token AccessManager, Rankify Diamond, 8x Rankify Diamond facets, RankTokenAccessManager, RankToken
+     * @dev `instances` array contents: GovernanceToken, Gov Token AccessManager, Governor, Rankify Diamond proxy, RankTokenAccessManager, RankToken
      */
     function instantiate(
         bytes calldata data
     ) public override returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion) {
         DistributorArguments memory args = abi.decode(data, (DistributorArguments));
 
-        (address[] memory tokenInstances, , ) = createToken(args.tokenSettings);
-        (address[] memory RankifyInstances, , ) = createRankify(args.rankifySettings, tokenInstances[0]);
+        (address[] memory tokenInstances, , ) = createOrg(args.govSettings);
+        (address[] memory RankifyInstances, , ) = createRankify(args.rankifySettings, tokenInstances[0], tokenInstances[2]);
 
         address[] memory returnValue = new address[](tokenInstances.length + RankifyInstances.length);
 
@@ -271,11 +297,11 @@ contract MAODistribution is IDistribution, CodeIndexer {
 
     function get() external view returns (address[] memory sources, bytes32, uint256) {
         address[] memory srcs = new address[](5);
-        srcs[0] = address(_trustedForwarder);
-        srcs[1] = address(_rankTokenBase);
-        srcs[2] = address(_RankifyDistributionBase);
-        srcs[3] = address(_governanceERC20Base);
-        srcs[4] = address(_accessManagerBase);
+        srcs[0] = address(_rankTokenBase);
+        srcs[1] = address(_RankifyDistributionBase);
+        srcs[2] = address(_governanceERC20Base);
+        srcs[3] = address(_accessManagerBase);
+        srcs[5] = address(_DAO);
         return (srcs, ShortString.unwrap(_distributionName), _distributionVersion);
     }
 
@@ -287,4 +313,15 @@ contract MAODistribution is IDistribution, CodeIndexer {
     function distributionSchema(DistributorArguments memory args) external pure returns (DistributorArguments memory) {
         return args;
     }
+
+    function parseAppComponents(address[] memory appComponents) internal pure returns (MAOApp memory) {
+        MAOApp memory app;
+        app.governanceToken = DistributableGovernanceERC20(appComponents[0]);
+        app.govTokenManager = SimpleAccessManager(appComponents[1]);
+        app.DAO = IGovernor(appComponents[2]);
+        app.fellowship = IRankifyInstance(appComponents[3]);
+        app.rankTokenManager = SimpleAccessManager(appComponents[4]);
+        app.rankToken = RankToken(appComponents[5]);
+        return app;
+    }
 }
diff --git a/test/MAODistribution.ts b/test/MAODistribution.ts
index 819180e..e329845 100644
--- a/test/MAODistribution.ts
+++ b/test/MAODistribution.ts
@@ -57,18 +57,21 @@ describe('MAODistribution', async function () {
       const { owner } = await getNamedAccounts();
       const oSigner = await ethers.getSigner(owner);
       const distributorArguments: MAODistribution.DistributorArgumentsStruct = {
-        tokenSettings: {
+        govSettings: {
           tokenName: 'tokenName',
           tokenSymbol: 'tokenSymbol',
           preMintAmounts: [ethers.utils.parseEther('100')],
           preMintReceivers: [oSigner.address],
+          orgName: 'orgName',
+          votingDelay: 3600,
+          votingPeriod: 3600,
+          quorum: 51,
         },
         rankifySettings: {
           rankTokenContractURI: 'https://example.com/rank',
           rankTokenURI: 'https://example.com/rank',
           principalCost: 1,
           principalTimeConstant: 1,
-          owner: oSigner.address,
           paymentToken: rankify.address,
         },
       };
@@ -97,18 +100,21 @@ describe('MAODistribution', async function () {
       const { owner } = await getNamedAccounts();
       const oSigner = await ethers.getSigner(owner);
       const distributorArguments: MAODistribution.DistributorArgumentsStruct = {
-        tokenSettings: {
+        govSettings: {
           tokenName: 'tokenName',
           tokenSymbol: 'tokenSymbol',
           preMintAmounts: [ethers.utils.parseEther('100')],
           preMintReceivers: [oSigner.address],
+          orgName: 'orgName',
+          votingDelay: 3600,
+          votingPeriod: 3600,
+          quorum: 51,
         },
         rankifySettings: {
           rankTokenContractURI: 'https://example.com/rank',
           rankTokenURI: 'https://example.com/rank',
           principalCost: 1,
           principalTimeConstant: 1,
-          owner,
           paymentToken: rankify.address,
         },
       };
diff --git a/test/RankifyInstance.ts b/test/RankifyInstance.ts
index d1e728c..2e5ba08 100644
--- a/test/RankifyInstance.ts
+++ b/test/RankifyInstance.ts
@@ -53,11 +53,15 @@ const setupMainTest = deployments.createFixture(async ({ deployments, getNamedAc
   const oSigner = await ethers.getSigner(owner);
   console.log('oSigner', oSigner.address);
   const distributorArguments: MAODistribution.DistributorArgumentsStruct = {
-    tokenSettings: {
+    govSettings: {
       tokenName: 'tokenName',
       tokenSymbol: 'tokenSymbol',
       preMintAmounts: [ethers.utils.parseEther('100')],
       preMintReceivers: [oSigner.address],
+      orgName: 'orgName',
+      votingDelay: 3600,
+      votingPeriod: 3600,
+      quorum: 51,
     },
     rankifySettings: {
       paymentToken: env.rankifyToken.address,
@@ -65,7 +69,6 @@ const setupMainTest = deployments.createFixture(async ({ deployments, getNamedAc
       rankTokenURI: 'https://example.com/rank',
       principalCost: constantParams.PRINCIPAL_COST,
       principalTimeConstant: constantParams.PRINCIPAL_TIME_CONSTANT,
-      owner,
     },
   };
   const data = generateDistributorData(distributorArguments);
